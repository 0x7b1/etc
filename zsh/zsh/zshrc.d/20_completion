# Whenever a command completion is attempted, make sure the entire command
# path is hashed first.
setopt hash_list_all

# If unset, the cursor is set to the end of the word if completion is
# started. Otherwise it stays there and completion is done from both ends.
setopt complete_in_word

# load fancy menu completion
zmodload zsh/complist

# initialize completion system
autoload -U compinit
compinit -d $XDG_CACHE_HOME/zsh/zcompdump


## general settings
# separate matches into groups
zstyle ':completion:*' group-name ''
# if there is more than 1 match allow selecting from a menu
zstyle ':completion:*' menu select=1
# zstyle ':completion:*' menu yes select interactive
# provide verbose completion information
zstyle ':completion:*' verbose true
# match uppercase from lowercase
if is-at-least 4.3; then
    zstyle ':completion:*' matcher-list 'm:{[:lower:]}={[:upper:]}'
else
    zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
fi
# show ignored matches if we really want to
zstyle ':completion:*' single-ignored show
# caching
zstyle ':completion:*' use-cache yes
zstyle ':completion:*' cache-path $XDG_CACHE_HOME/zsh/zcompcache/
# activate color-completion
zstyle ':completion:*:default' list-colors ${(s.:.)LS_COLORS}

zstyle ':completion:*' squeeze-slashes true
zstyle ':completion:*' list-dirs-first true # affects all-files/other-files
zstyle ':completion:*' ignore-parents parent pwd

# prevent asking with many results
# zstyle ':completion:*:default' list-prompt '%p'
zstyle ':completion:*:descriptions' format $'%{\e[0;32m%}completing %B%d%b%{\e[0m%}'
zstyle ':completion:*:messages'     format '%d'
zstyle ':completion:*:warnings'     format $'%{\e[0;31m%}No matches for:%{\e[0m%} %d'
zstyle ':completion:*:options'      auto-description '%d'


## correction
# run rehash on completion so newly installed programs are found automatically
_force_rehash() {
    (( CURRENT == 1 )) && rehash
    return 1 # Because we didn't really complete anything
}
zstyle -e ':completion:*' completer '
if [[ $_last_try != "$HISTNO$BUFFER$CURSOR" ]]; then
    _last_try="$HISTNO$BUFFER$CURSOR"
    reply=(_complete _match _prefix)
else
    if [[ $words[1] == (rm|mv) ]]; then
        reply=(_complete)
    else
        reply=(_oldlist _force_rehash _complete _correct _approximate _ignored)
    fi
fi'
zstyle ':completion:*:correct:*'   insert-unambiguous true
zstyle ':completion:*:correct:*'   original true
zstyle ':completion:*:correct:*'   max-errors 2
zstyle ':completion:*:corrections' format $'%{\e[0;31m%}%d (errors: %e)%{\e[0m%}'
# allow one error for every three characters typed in approximate completer
zstyle ':completion:*:approximate:*' max-errors 'reply=( $(( ($#PREFIX+$#SUFFIX)/3 )) numeric )'


## ZSH stuff
# complete 'cd -<tab>' with menu
zstyle ':completion:*:*:cd:*:directory-stack' menu yes select
# offer indexes before parameters in subscripts
zstyle ':completion:*:*:-subscript-:*'        tag-order indexes parameters
# define files to ignore for zcompile
zstyle ':completion:*:*:zcompile:*'           ignored-patterns '(*~|*.zwc)'
# insert all expansions for expand completer
zstyle ':completion:*:expand:*'               tag-order all-expansions
# Ignore completion functions for commands you don't have:
zstyle ':completion::(^approximate*):*:functions' ignored-patterns '_*'
# don't complete files already in the command line
zstyle ':completion:*:other-files' ignore-line other
zstyle ':completion:*:directories' ignore-line other
# ... except for mv and cp
zstyle ':completion:*:(mv|cp):*' ignore-line no
# zstyle ':completion:*:(rm|kill|diff):*' ignore-line other

# history word completion (^[/)
zstyle ':completion:*:history-words' list false
zstyle ':completion:*:history-words' menu yes
zstyle ':completion:*:history-words' remove-all-dups yes
zstyle ':completion:*:history-words' stop yes


## external commands
# describe options in full
zstyle ':completion:*:options'                      description 'yes'

# don't complete backup files as executables
zstyle ':completion:*:complete:-command-::commands' ignored-patterns '*\~'
zstyle ':completion:*:*:(^rm):*:*' ignored-patterns '*(.o|~)' '#*#(D)'
zstyle ':completion:*:*:vim:*:*' ignored-patterns '(|**/)tags' '*.aux' '*.log' '*.pdf'

zstyle ':completion:*:processes'          command 'ps xwww --forest -o pid,%cpu,tty,time,command'
zstyle ':completion:*:kill:*'             force-list always
zstyle ':completion:*:*:kill:*:processes' list-colors '=(#b) #([0-9]#)*=0=01;31'

# complete manual by their section
zstyle ':completion:*:manuals'   separate-sections true
zstyle ':completion:*:manuals.*' insert-sections   true
zstyle ':completion:*:man:*'     menu yes no-select

# make ./configure completion simpler
zstyle ':completion:*:*:-command-:*' ignored-patterns './config.*'

# host completion /* add brackets as vim can't parse zsh's complex cmdlines {{{ */
[[ -r ~/.ssh/known_hosts ]] && _ssh_hosts=(${${${${(f)"$(<$HOME/.ssh/known_hosts)"}:#[\|]*}%%\ *}%%,*}) || _ssh_hosts=()
[[ -r /etc/hosts ]] && : ${(A)_etc_hosts:=${(s: :)${(ps:\t:)${${(f)~~"$(</etc/hosts)"}%%\#*}##[:blank:]#[^[:blank:]]#}}} || _etc_hosts=()
hosts=(
    majutsushi.net
    "$_ssh_hosts[@]"
    "$_etc_hosts[@]"
    $(hostname)
    localhost
)
zstyle ':completion:*:hosts' hosts $hosts
zstyle ':completion:*:hosts' ignored-patterns 'ip6-*'

zstyle ':completion:*:users' ignored-patterns avahi avahi-autoipd backup bin bitlbee \
    cl-builder colord daemon Debian-exim Debian-gdm festival fetchmail games gnats hplip \
    irc lastfm libuuid list lp mail man messagebus minbif mpd news nobody ntp polkituser \
    proxy saned spampd sshd statd sync sys timidity uml-net usbmux uucp www-data '_*'


# use generic completion for programs that support --help
compdef _gnu_generic tail head cp mv df uname ack-grep

compdef '_files -g "*.(#l)(tar.bz2|tbz2|tbz|tar.gz|tgz|tar.xz|txz|tar.lzma|tar|rar|lzh|7z|zip|jar|deb|bz2|gz|Z|xz|lzma)"' extract

# menu selection: pick item but stay in the menu (press esc-return)
bindkey -M menuselect '\e^M' accept-and-menu-complete

# http://stackoverflow.com/a/844299/102250
# show dots while completion is working
expand-or-complete-with-dots() {
    echo -ne "\e[31m......\e[0m"
    zle expand-or-complete
    zle redisplay
}
zle -N expand-or-complete-with-dots
bindkey "^I" expand-or-complete-with-dots

# force file completion
zle -C complete-files complete-word _generic
zstyle ':completion:complete-files:*' completer _files
bindkey "^X^F" complete-files
# allow the key sequence to continue cycling in menu
bindkey -M menuselect "^X^F" complete-word

## complete word from currently visible Screen or Tmux buffer.
# http://git.grml.org/?p=grml-etc-core.git;a=blob;f=etc/zsh/zshrc;h=bf40267af60a9aef5721b63b9fd4a61686e1b15c;hb=HEAD
# http://blog.plenz.com/2012-01/zsh-complete-words-from-tmux-pane.html
_current_screen_words() {
    [[ "$TERM" != screen* ]] && return 1

    local expl
    local -U -a words

    # fill array with contents from tmux/screen hardcopy
    if ((${+TMUX})); then
        words=( ${(u)=$(tmux capture-pane \; show-buffer \; delete-buffer)} )
    else
        local TMPFILE=$(mktemp)
        trap "rm -f $TMPFILE" EXIT
        screen -X hardcopy $TMPFILE
        # screen sucks, it dumps in latin1, apparently always. so recode it
        # to system charset
        have recode && recode latin1 $TMPFILE
        words=( ${(QQ)$(<$TMPFILE)} )
    fi
    # remove PREFIX to be completed from that array
    words[${words[(i)$PREFIX]}]=""
    _wanted values expl 'words from current screen' compadd -a words
}
zle -C current-screen-words-prefix   complete-word _generic
zle -C current-screen-words-anywhere complete-word _generic
bindkey '^[o' current-screen-words-prefix
bindkey -M menuselect '^[o' complete-word
bindkey '^[O' current-screen-words-anywhere
bindkey -M menuselect '^[O' complete-word
zstyle ':completion:current-screen-words-(prefix|anywhere):*' completer _current_screen_words
zstyle ':completion:current-screen-words-(prefix|anywhere):*' ignore-line current
zstyle ':completion:current-screen-words-anywhere:*' matcher-list 'b:=* m:{A-Za-z}={a-zA-Z}'


# GitHub 'hub' completion
if is-at-least 4.3; then
    # Autoload _git completion functions
    if declare -f _git > /dev/null; then
        _git
    fi

    if declare -f _git_commands > /dev/null; then
        _hub_commands=(
            'alias:show shell instructions for wrapping git'
            'pull-request:open a pull request on GitHub'
            'fork:fork origin repo on GitHub'
            'create:create new repo on GitHub for the current project'
            'browse:browse the project on GitHub'
            'compare:open GitHub compare view'
        )
        # Extend the '_git_commands' function with hub commands
        # eval "$(declare -f _git_commands | sed -e 's/base_commands=(/base_commands=(${_hub_commands} /')"
        eval "$(declare -f _git_commands | sed -e 's/main_porcelain_commands=(/main_porcelain_commands=(${_hub_commands} /')"
    fi
    compdef hub=git
fi

# vim: filetype=zsh
