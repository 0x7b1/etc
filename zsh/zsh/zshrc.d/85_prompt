precmd () {
    # handle deleted and then recreated directories
    if ! [[ . -ef $PWD ]]; then
        if ! cd -- "${PWD}" >/dev/null 2>&1; then
            echo "W: ${PWD} does not exist anymore"
            return 1
        fi
    fi

    # adjust title of xterm
    # see http://www.faqs.org/docs/Linux-mini/Xterm-Title.html
    case $TERM in (xterm*|rxvt*|screen*)
        print -Pn "\e]0;%n@%m: %~\a"
        ;;
    esac
    if [[ "$TERM" == screen* ]]; then
        if [[ -n "$SSH_CLIENT" ]]; then
            print -Pn "\ek%m\e\\"
        else
            echo -ne "\ekzsh\e\\"
        fi
    fi
}

preexec () {
    # get the name of the program currently running and hostname of local machine
    # set screen window title if running in a screen
    if [[ "$TERM" == screen* ]]; then
        local CMD="${1[(wr)^(*=*|sudo|(auto)?ssh|-*)]//*\//}${SSH_CLIENT:+@${HOST//.*/}}"
        echo -ne "\ek$CMD\e\\"
    fi
    # adjust title of xterm
    case $TERM in (xterm*|rxvt*|screen*)
        print -Pn "\e]0;%n@%m: $1\a"
        ;;
    esac
}

setopt prompt_subst

__prompt_jobs() {
    echo '%(1j.%{%B%F{cyan}%}%j%{%b%f%}.)'
}

__prompt_exitcode() {
    echo '%(0?..%{%B%F{red}%}%?%{%b%f%})%(1j. .)'
}

# test if we have writing permission for the current directory
__prompt_wperm(){
    if ! [[ -w "$(pwd)" ]]; then
        echo "%{%B%F{red}%}!%{%b%f%}"
    fi
}

__gitdir ()
{
    if [ -n "${__git_dir-}" ]; then
        echo "$__git_dir"
    elif [ -d .git ]; then
        echo .git
    else
        git rev-parse --git-dir 2>/dev/null
    fi
}

__git_ps1()
{
    local gitdir="$(__gitdir)"
    if [ -n "$gitdir" ]; then
        local rebase=""
        local branch=""
        local extra=""
        if [ -f "$gitdir/rebase-merge/interactive" ]; then
            rebase="rebase-i"
            branch="$(cat "$gitdir/rebase-merge/head-name")"
        elif [ -d "$gitdir/rebase-merge" ]; then
            rebase="rebase-m"
            branch="$(cat "$gitdir/rebase-merge/head-name")"
        else
            if [ -d "$gitdir/rebase-apply" ]; then
                if [ -f "$gitdir/rebase-apply/rebasing" ]; then
                    rebase="rebase"
                elif [ -f "$gitdir/rebase-apply/applying" ]; then
                    rebase="am"
                else
                    rebase="am/rebase"
                fi
            elif [ -f "$gitdir/MERGE_HEAD" ]; then
                rebase="merging"
            elif [ -f "$gitdir/CHERRY_PICK_HEAD" ]; then
                rebase="cherry-picking"
            elif [ -f "$gitdir/BISECT_LOG" ]; then
                rebase="bisecting"
            fi

            if branch="$(git symbolic-ref HEAD 2>/dev/null)" ||
                branch="$(git describe --tags --exact-match HEAD 2>/dev/null)"; then
                extra="$(git show --pretty=format:%d -s HEAD)"
                extra="${extra// }"
                extra="${extra//\(}"
                extra="${extra//\)}"

                # remove redundant info
                earr=("${(s:,:)extra}")
                earr=(${earr:#HEAD})
                earr=(${earr//${branch#refs\/heads\/}})
                earr=(${earr//*\/*})

                if [[ -n ${(j::)earr} ]]; then
                    local col="%{%B%F{cyan}%}"
                    local colres="%{%f%}"
                    extra=" ● $col${(j:,:)earr}"
                    extra="${extra//,/$colres, $col}%{%f%b%}"
                else
                    extra=""
                fi
            elif branch="$(cut -c1-7 "$gitdir/HEAD" 2>/dev/null)..."; then
                extra=" ● %{%B%F{cyan}%}$(git describe --all HEAD 2>/dev/null)%{%b%f%}"
            else
                branch="unknown"
            fi
            branch="$branch"
        fi

        local w=""
        local i=""
        local s=""
        local u=""
        local c=""
        local p=""

        if [ "true" = "$(git rev-parse --is-inside-git-dir 2>/dev/null)" ]; then
            if [ "true" = "$(git rev-parse --is-bare-repository 2>/dev/null)" ]; then
                c="BARE:"
            else
                branch="GIT_DIR!"
            fi
        elif [ "true" = "$(git rev-parse --is-inside-work-tree 2>/dev/null)" ]; then

            # show dirty state
            # --ignore-submodules can significantly speed up if submodules
            # are present
            git diff --no-ext-diff --quiet --exit-code --ignore-submodules || w="%{%F{cyan}%}*%{%f%}"
            if git rev-parse --quiet --verify HEAD >/dev/null; then
                git diff-index --cached --quiet HEAD -- || i="%{%F{cyan}%}+%{%f%}"
            else
                i="%{%F{cyan}%}#%{%f%}"
            fi

            # show stashed changes
            git rev-parse --verify refs/stash >/dev/null 2>&1 && s="%{%F{cyan}%}$%{%f%}"

            # show untracked files
            if [ -n "$(git ls-files --others --exclude-standard)" ]; then
                u="%{%F{cyan}%}%%%{%f%}"
            fi

            if [ -n "${GIT_PS1_SHOWUPSTREAM-}" ]; then
                __git_ps1_show_upstream
            fi
        fi

        local flags="$w$i$s$u"
        if [[ -n "$rebase" ]]; then
            rebase=" %{%F{167}%}${rebase}%{%f%}"
        fi
        local svn=""
        if [[ -d ${gitdir}/svn ]]; then
            svn="s"
        fi
        echo " %{%B%}±$svn %{%F{220}%}$c${branch##refs/heads/}${flags:+$flags}$rebase$p%{%b%f%}$extra"
    fi
}

PS1='
%{%F{167}%B%}%n %{%f%}%}@ %{%F{220}%}%m%{%b%f%} ● %{%B%F{green}%}%<...<%~%<<%{%f%b%}$(__prompt_wperm)$(__git_ps1)
%(!.#.>) '

RPS1='$(__prompt_exitcode)$(__prompt_jobs)'

PS2="%{%B%}%_%{%b%} %(!.#.>) "
PS3='?# '         # selection prompt used within a select loop.
PS4='+%N:%i:%_> ' # the execution trace prompt (setopt xtrace). default: '+%N:%i>'

# vim: filetype=zsh
