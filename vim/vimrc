" Important stuff at the beginning {{{1
set nocompatible
set encoding=utf-8
let mapleader=","

let g:user_name = "Jan Larres"
let g:user_email = "jan@majutsushi.net"

let g:pathogen_disabled = []
if v:version < 703
    let g:pathogen_disabled += ['gundo']
endif
if !has('gui') && v:version < 703
    let g:pathogen_disabled += ['csapprox']
endif

runtime bundle/pathogen/autoload/pathogen.vim
call pathogen#infect('bundle/{}', '~/src/vim/bundle/{}')

if !isdirectory($HOME . "/.cache/vim") && exists("*mkdir")
    call mkdir($HOME . "/.cache/vim")
    call mkdir($HOME . "/.cache/vim/swap")
endif

" search for exuberant ctags
let ctagsbins  = []
let ctagsbins += [expand('~/src/ctags/ctags/dctags')]
let ctagsbins += ['ctags-exuberant'] " Debian
let ctagsbins += ['exuberant-ctags']
let ctagsbins += ['exctags'] " FreeBSD, NetBSD
let ctagsbins += ['/usr/local/bin/ctags'] " Homebrew
let ctagsbins += ['/opt/local/bin/ctags'] " Macports
let ctagsbins += ['ectags'] " OpenBSD
let ctagsbins += ['ctags']
let ctagsbins += ['ctags.exe']
let ctagsbins += ['tags']
let g:ctagsbin = ''
for ctags in ctagsbins
    if executable(ctags)
        let g:ctagsbin = ctags
        break
    endif
endfor
unlet ctagsbins

" Autocommands {{{1

" remove all autocommands to avoid sourcing them twice
augroup vimrc
    autocmd!
augroup END

set cursorline
autocmd vimrc InsertLeave * set cursorline
autocmd vimrc InsertEnter * set nocursorline

autocmd vimrc StdinReadPost * set buftype=nofile

" Don't screw up folds when inserting text that might affect them, until
" leaving insert mode. Foldmethod is local to the window. Protect against
" screwing up folding when switching between windows.
autocmd vimrc InsertEnter * if !exists('w:last_fdm') | let w:last_fdm=&foldmethod | setlocal foldmethod=manual | endif
autocmd vimrc InsertLeave,WinLeave * if exists('w:last_fdm') | let &l:foldmethod=w:last_fdm | unlet w:last_fdm | endif

" inspired by https://github.com/kana/vim-tabpagecd
autocmd vimrc TabEnter * if exists('t:cwd') | execute 'cd ' . fnameescape(t:cwd) | endif
autocmd vimrc TabLeave * let t:cwd = getcwd()

autocmd vimrc BufNewFile,BufWritePre * call AutoMkDir()

" create undo break point
autocmd vimrc CursorHoldI * call feedkeys("\<C-G>u", "nt")

" When switching buffers, preserve window view.
function! IsNotSpecialBuf(buf) abort
    return ((&buftype != "quickfix") &&
          \ !&previewwindow &&
          \ !&scrollbind &&
          \ (bufname(a:buf) !~ "NERD_tree") &&
          \ (bufname(a:buf) !~ "__Tag_List__") &&
          \ (bufname(a:buf) !~ "__Tagbar__") &&
          \ (bufname(a:buf) !~ "fugitive*"))
endfunction
if v:version >= 700
    autocmd vimrc BufLeave * if IsNotSpecialBuf("%") | let b:winview = winsaveview() | endif
    autocmd vimrc BufEnter * if (exists('b:winview') && IsNotSpecialBuf("%")) | call winrestview(b:winview) | endif
endif

" automatically give executable permissions if file begins with #!
" and contains" '/bin/' in the path
" From https://github.com/mitechie/pyvim/blob/master/.vimrc
autocmd vimrc BufWritePost * if getline(1) =~ "^#!" | if getline(1) =~ "/bin/" | execute 'silent !chmod u+x <afile>' | endif | endif

" filetype-specific settings
augroup vimrc
    autocmd FileType make      setlocal noexpandtab tabstop=8 shiftwidth=8 softtabstop=0
    autocmd FileType gtkrc     setlocal tabstop=2 shiftwidth=2 softtabstop=2
    autocmd FileType haskell   compiler ghc
    autocmd FileType ruby      setlocal omnifunc=rubycomplete#Complete
    autocmd FileType gitcommit setlocal textwidth=72
augroup END

augroup commentstrings
    autocmd!
    autocmd FileType cpp  setlocal commentstring=//%s
    autocmd FileType tmux setlocal commentstring=#%s
    autocmd FileType pentadactyl setlocal commentstring=\"%s
augroup END

autocmd vimrc BufNewFile,BufReadPost *mutt/fortunes* setlocal textwidth=76
autocmd vimrc BufWritePost           *mutt/fortunes* silent !strfile <afile> >/dev/null

autocmd vimrc BufReadPost emacsfilevars.vim let b:emacs_ignore_file = 1

" Statusline {{{1
" Adapted from https://github.com/Lokaltog/sync/blob/master/vim/vimrc

" s:StatusLine() {{{2
function! s:StatusLine(new_stl, type, current)
    let current = (a:current ? "" : "NC")
    let new_stl = a:new_stl

    " Prepare current buffer specific text
    " Syntax: <CUR> ... </CUR>
    let new_stl = substitute(new_stl, '<CUR>\(.\{-,}\)</CUR>', (a:current ? '\1' : ''), 'g')

    " Prepare statusline colors
    " Syntax: #[ ... ]
    let new_stl = substitute(new_stl, '#\[Mode\]', '%#StatusLineMode' . a:type . '#', 'g')
    let new_stl = substitute(new_stl, '#\[\(\w\+\)\]',
                           \ '%#StatusLine' . '\1' . current . '#', 'g')

    if &l:statusline ==# new_stl
        " Statusline already set, nothing to do
        return
    endif

    if empty(&l:statusline)
        " No statusline is set, use new_stl
        let &l:statusline = new_stl
    else
        " Check if a custom statusline is set
        let plain_stl = substitute(&l:statusline, '%#StatusLine\w\+#', '', 'g')

        if &l:statusline ==# plain_stl
            " A custom statusline is set, don't modify
            return
        endif

        " No custom statusline is set, use new_stl
        let &l:statusline = new_stl
    endif
endfunction

" s:StatusLineColors() {{{2
function! s:StatusLineColors(colors)
    for name in keys(a:colors)
        let colors = {'c': a:colors[name][0], 'nc': a:colors[name][1]}
        let name = (name == 'NONE' ? '' : name)

        if exists("colors['c'][0]")
            exec 'hi StatusLine' . name .
               \ ' guibg=' . colors['c'][0] .
               \ ' guifg=' . colors['c'][1] .
               \ ' gui='   . colors['c'][2]
        endif

        if exists("colors['nc'][0]")
            exec 'hi StatusLine' . name . 'NC' .
               \ ' guibg=' . colors['nc'][0] .
               \ ' guifg=' . colors['nc'][1] .
               \ ' gui='   . colors['nc'][2]
        endif
    endfor
endfunction

" Colour definitions {{{2
let s:statuscolors = {
    \ 'ModeNormal'   : [[ '#4e9a06', '#ffffff', 'bold'], [                             ]],
    \ 'ModeInsert'   : [[ '#cc0000', '#ffffff', 'bold'], [                             ]],
    \ 'FilePath'     : [[ '#c2bfa5', '#000000', 'none'], [ '#1c1c1c', '#808080', 'none']],
    \ 'FileName'     : [[ '#c2bfa5', '#000000', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'ModFlag'      : [[ '#c2bfa5', '#cc0000', 'bold'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'BufFlag'      : [[ '#c2bfa5', '#000000', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'FileType'     : [[ '#585858', '#bcbcbc', 'none'], [ '#080808', '#4e4e4e', 'none']],
    \ 'Branch'       : [[ '#585858', '#bcbcbc', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'BranchS'      : [[ '#585858', '#949494', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'FunctionName' : [[ '#1c1c1c', '#9e9e9e', 'none'], [ '#080808', '#4e4e4e', 'none']],
    \ 'FileFormat'   : [[ '#1c1c1c', '#bcbcbc', 'bold'], [ '#080808', '#4e4e4e', 'none']],
    \ 'FileEncoding' : [[ '#1c1c1c', '#bcbcbc', 'bold'], [ '#080808', '#4e4e4e', 'none']],
    \ 'Separator'    : [[ '#1c1c1c', '#6c6c6c', 'none'], [ '#080808', '#4e4e4e', 'none']],
    \ 'ExpandTab'    : [[ '#585858', '#eeeeee', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'LineNumber'   : [[ '#585858', '#bcbcbc', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'LineColumn'   : [[ '#585858', '#bcbcbc', 'none'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'LinePercent'  : [[ '#c2bfa5', '#303030', 'bold'], [ '#1c1c1c', '#4e4e4e', 'none']],
    \ 'Warning'      : [[ '#cc0000', '#ffffff', 'bold'], [ '#1c1c1c', '#808080', 'none']],
    \ 'Error'        : [[ '#585858', '#ff5f00', 'bold'], [ '#1c1c1c', '#4e4e4e', 'none']]
\ }
" Helper functions {{{2
" GetFilePath() {{{3
function! GetFilePath()
    if &buftype == 'help' || &buftype == 'quickfix' || bufname('%') == ''
        return ''
    else
        let path = expand('%:p:~:.')
        if winwidth(0) - len(path) < 65
            let path = pathshorten(path)
        endif
        let path = fnamemodify(path, ':h')
        if path == '.'
            return ''
        else
            return path . '/'
        endif
    endif
endfunction

" GetFileName() {{{3
function! GetFileName()
    if &buftype == 'help'
        return expand('%:p:t')
    elseif &buftype == 'quickfix'
        return '[Quickfix List]'
    elseif bufname('%') == ''
        return '[No Name]'
    else
        let filename = expand('%:p:~:.')
        if winwidth(0) - len(filename) < 65
            let filename = pathshorten(filename)
        endif
        return fnamemodify(filename, ':t')
    endif
endfunction

" GetState() {{{3
function! GetState()
    if &buftype == 'help'
        return 'H'
    elseif &readonly || &buftype == 'nowrite' || &modifiable == 0
        return '-'
    elseif &modified != 0
        return '*'
    else
        return ''
    endif
endfunction

" GetFileformat() {{{3
function! GetFileFormat()
    if &fileformat == '' || &fileformat == 'unix'
        return ''
    else
        return &fileformat
    endif
endfunction

" GetFileencoding() {{{3
function! GetFileEncoding()
    if empty(&fileencoding) || &fileencoding == 'utf-8'
        return ''
    else
        return &fileencoding
    endif
endfunction

" s:recompute_stl_ws() {{{3
" Adapted from
" http://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
function! s:recompute_stl_ws() abort
    let tabs = search('^\t', 'nw') != 0
    let spaces = search('^ ', 'nw') != 0

    if tabs && spaces
        let b:statusline_tab_warning = 'mixed'
    " elseif (spaces && !&et) || (tabs && &et)
    "     let b:statusline_tab_warning = 'wrong'
    else
        let b:statusline_tab_warning = ''
    endif
endfunction
autocmd vimrc BufReadPost,CursorHold,BufWritePost * call s:recompute_stl_ws()
" StatuslineETString() {{{3
function! StatuslineETString(error) abort
    if !exists('b:statusline_tab_warning')
        call s:recompute_stl_ws()
    endif

    if b:statusline_tab_warning == 'mixed' && a:error ||
     \ b:statusline_tab_warning == '' && !a:error
        return &expandtab ? 'S' : 'T'
    else
        return ''
    endif
endfunction

" StatuslineTrailingSpaceWarning() {{{3
" Adapted from
" http://got-ravings.blogspot.com/2008/10/vim-pr0n-statusline-whitespace-flags.html
function! StatuslineTrailingSpaceWarning()
    if !exists("b:statusline_trailing_space_warning")
        if search('\s\+$', 'nw') != 0
            let b:statusline_trailing_space_warning = '·'
        else
            let b:statusline_trailing_space_warning = ''
        endif
    endif
    return b:statusline_trailing_space_warning
endfunction
autocmd vimrc CursorHold,BufWritePost * unlet! b:statusline_trailing_space_warning

" EclimErrorIndicator() {{{3
function! EclimErrorIndicator() abort
    let loclist = filter(getloclist(0), 'bufnr("%") == v:val.bufnr')
    let errors = filter(copy(loclist), 'tolower(v:val.type) == "e"')

    return len(errors) > 0 ? 'e' : ''
endfunction

" Default statusline {{{2
let g:default_stl  = ""

let g:default_stl .= "<CUR>#[Mode] "
let g:default_stl .= "%{substitute(mode(), '', '^V', 'g')} "
let g:default_stl .= "%{&paste ? '(paste) ' : ''}"
let g:default_stl .= "</CUR>"

" File name
let g:default_stl .= "#[FilePath] %{GetFilePath()}#[FileName]%{GetFileName()} "

let g:default_stl .= "#[ModFlag]%(%{GetState()} %)#[BufFlag]%w"

let g:default_stl .= "#[Warning]%{EclimErrorIndicator()}"

" File type
let g:default_stl .= "<CUR>%(#[FileType] %{!empty(&ft) ? &ft : '--'}#[BranchS]%)</CUR>"

" Spellcheck language
let g:default_stl .= "<CUR>%(#[FileType]%{&spell ? ':' . &spelllang : ''}#[BranchS]%)</CUR>"

" Git branch
let g:default_stl .= "#[Branch]%("
let g:default_stl .= "%{exists('g:loaded_fugitive') ? substitute(fugitive#statusline(), '\\[GIT(\\([a-z0-9\\-_\\./:]\\+\\))\\]', '<CUR>:</CUR>\\1', 'gi') : ''}"
let g:default_stl .= "%) "

" Syntastic
"let g:default_stl .= "<CUR>%(#[BranchS][>] #[Error]%{substitute(SyntasticStatuslineFlag(), '\\[Syntax: line:\\(\\d\\+\\) \\((\\(\\d\\+\\))\\)\\?\\]', '[>][>][>] SYNTAX \\1 \\2 [>][>][>]', 'i')} %)</CUR>"
"let g:default_stl .= "<CUR>%(#[BranchS][>] #[Error]%{substitute('[Syntax: line:42 (99)]', '\\[Syntax: line:\\(\\d\\+\\) \\((\\(\\d\\+\\))\\)\\?\\]', 'SYNTAX \\1 \\2', 'i')} %)</CUR>"

" Padding/HL group
let g:default_stl .= "#[FunctionName] "

" Truncate here
let g:default_stl .= "%<"

" Function name
" let g:default_stl .= "<CUR>%(%{tagbar#currenttag('%s', '')} %)</CUR>"
let g:default_stl .= "%(%{tagbar#currenttag('%s', '')} %)"

" Current directory
" let g:default_stl .= "%{fnamemodify(getcwd(), ':~')}"

" Right align rest
let g:default_stl .= "%= "

" File format
let g:default_stl .= '<CUR>%(#[FileFormat]%{GetFileFormat()} %)</CUR>'

" File encoding
let g:default_stl .= '<CUR>%(#[FileFormat]%{GetFileEncoding()} %)</CUR>'

" BOM
let g:default_stl .= '<CUR>%(#[FileFormat]%{&bomb ? "BOM" : ""} %)</CUR>'

let g:default_stl .= "#[ExpandTab] "

" ZoomWin state
let g:default_stl .= "%(#[Warning]%{g:zoomwin_stl}#[ExpandTab] %)"

" Tabstop/indent/whitespace settings
let g:default_stl .= "%(#[Warning]"
let g:default_stl .= "%{StatuslineTrailingSpaceWarning()}"
let g:default_stl .= "#[ExpandTab] %)"

let g:default_stl .= "#[Warning]%{StatuslineETString(1)}#[ExpandTab]%{StatuslineETString(0)}"
let g:default_stl .= "#[LineColumn]:%{&tabstop}:%{&softtabstop}:%{&shiftwidth}"

" Unicode codepoint
"let g:default_stl .= '<CUR>#[LineNumber] U+%04B</CUR>'

" Line/column/virtual column, Line percentage
let g:default_stl .= "#[LineNumber] %04(%l%)#[LineColumn]:%03(%c%V%) "

" Line/column/virtual column, Line percentage
let g:default_stl .= "#[LinePercent] %p%%"

" Current syntax group
"let g:default_stl .= "%{exists('g:synid') && g:synid ? '| '.synIDattr(synID(line('.'), col('.'), 1), 'name').' ' : ''}"

" Autocommands {{{2
augroup StatusLineHighlight
    autocmd!

    autocmd ColorScheme * call <SID>StatusLineColors(s:statuscolors)

    autocmd BufEnter,BufWinEnter,WinEnter,CmdwinEnter,CursorHold,BufWritePost,InsertLeave * call <SID>StatusLine((exists('b:stl') ? b:stl : g:default_stl), 'Normal', 1)
    autocmd BufLeave,BufWinLeave,WinLeave,CmdwinLeave * call <SID>StatusLine((exists('b:stl') ? b:stl : g:default_stl), 'Normal', 0)
    autocmd InsertEnter,CursorHoldI * call <SID>StatusLine((exists('b:stl') ? b:stl : g:default_stl), 'Insert', 1)
augroup END

" Functions {{{1

" AutoMkDir() {{{2
" Automatically create dir to write file to if it doesn't exist
function! AutoMkDir()
    let file = expand('<afile>')
    if file =~# '^[a-z]\+:\/\/'
        " Netrw file or similar, don't try creating the directory
        return
    endif
    let required_dir = fnamemodify(file, ':p:h')
    if !isdirectory(required_dir)
        if confirm("Directory '" . required_dir . "' doesn't exist.", "&Abort\n&Create it") != 2
            bdelete
            return
        endif

        try
            call mkdir(required_dir, 'p')
        catch
            if confirm("Can't create '" . required_dir . "'", "&Abort\n&Continue anyway") != 2
                bdelete
                return
            endif
        endtry
    endif
endfunction

" Bclose() {{{2
" delete buffer without closing window
function! Bclose()
    let curbufnr = bufnr("%")
    let altbufnr = bufnr("#")

    if buflisted(altbufnr)
        buffer #
    else
        bnext
    endif

    if bufnr("%") == curbufnr
        new
    endif

    if buflisted(curbufnr)
        execute("bdelete! " . curbufnr)
    endif
endfunction

" CenterBlock() {{{2
function! CenterBlock(...) range
    let width = a:0 > 0 ? a:1 : (&textwidth > 0 ? &textwidth : 80)
    let left  = width
    let right = 1

    for linenr in range(a:firstline, a:lastline)
        let line = getline(linenr)
        if line =~ '^$'
            continue
        endif

        let l = match(line, '\S') + 1
        if l < left
            let left = l
        endif

        let r = len(line)
        if r > right
            let right = r
        endif
    endfor

    if left > right
        echoerr 'No valid region found!'
        return
    endif
    if right > width
        echoerr 'Width is too small!'
        return
    endif

    let mean = float2nr(round((left + (width - right)) / 2.0))

    if mean > left
        for linenr in range(a:firstline, a:lastline)
            let line = getline(linenr)
            if line =~ '^$'
                continue
            endif
            let padding = repeat(' ', mean - left)
            let line = substitute(line, '.*', padding . '\0', '')
            call setline(linenr, line)
        endfor
    else
        for linenr in range(a:firstline, a:lastline)
            let line = getline(linenr)
            if line =~ '^$'
                continue
            endif
            let line = substitute(line, '\s\{' . (left - mean) . '\}', '', '')
            call setline(linenr, line)
        endfor
    endif
endfunction

command! -range -nargs=? CenterBlock <line1>,<line2>call CenterBlock(<f-args>)

" CtrlG() {{{2
function! CtrlG() abort
    redir => default
    execute "silent normal! \<C-g>"
    redir END
    " remove weird null bytes from the beginning
    let default = substitute(default, '^.\{-}\ze"', '', '')
    echo default fnamemodify(getcwd(), ':~')
endfunction
nnoremap <C-g> :call CtrlG()<CR>

" DiffOrig() {{{2
" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
" Only define it when not defined already.
if !exists(":DiffOrig")
    command DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis | wincmd p | diffthis
endif

" s:fakemap() {{{2
function! s:fakemap(target) abort
    execute 'map <Plug>Fake' . s:fakemap_idx . ' ' . a:target
    let s:fakemap_idx += 1
endfunction
let s:fakemap_idx = 0

" FindAutocmdTouching() {{{2
" Find autocmds that set certain parameters
" From https://groups.google.com/group/vim_use/msg/91d0d2bd87ce59e1
function! FindAutocmdTouching(...)
    " capture the text of existing autocmds
    redir => aucmds
    silent! au
    redir END
    let found = {}
    let evt = 'unknown'
    for line in split(aucmds, '\n')
        " lines starting with non-whitespace are event names
        if line =~ '^\S'
            let evt = line
            continue
        endif
        " add an entry if the line matches any of the passed patterns
        if len(filter(copy(a:000), 'line =~ v:val'))
            let found[evt] = get(found, evt, []) + [line]
        endif
    endfor

    " print a small report of what was found
    if len(found)
        for [k, v] in items(found)
            echo "autocmd" k
            for line in v
                echo line
            endfor
        endfor
    else
        echo "None found"
    endif
endfun

" check for the two variants of 'spellcapcheck'
"call FindAutocmdTouching('spellcapcheck','spc')

" GenerateFoldText() {{{2
" adjusted from http://vim.wikia.com/wiki/Customize_text_for_closed_folds
function! GenerateFoldText()
    let line = getline(v:foldstart)
    if match(line, '^[ \t]*\(\/\*\|\/\/\)[*/\\]*[ \t]*$') == 0
        " Fold is a comment block starting with '/*' or '//'
        " Use the text of the first non-empty line for the foldtext
        let initial = substitute(line, '^\([ \t]\)*\(\/\*\|\/\/\)\(.*\)', '\1\2', '')
        let linenum = v:foldstart + 1
        while linenum < v:foldend
            let line            = getline(linenum)
            let comment_content = substitute(line, '^\([ \t\/\*]*\)\(.*\)$', '\2', 'g')
            if comment_content != ''
                break
            endif
            let linenum = linenum + 1
        endwhile
        let text = initial . ' ' . comment_content
    else
        let text = line

        " Foldtext can't display tabs so replace them with spaces
        let indent = indent(v:foldstart)
        let text   = substitute(text, '^\t\+', repeat(' ', indent), '')

        " Replace content between {} with {...}
        let startbrace = substitute(line, '^.*{[ \t]*$', '{', 'g')
        if startbrace == '{'
            let line     = getline(v:foldend)
            let endbrace = substitute(line, '^[ \t]*}\(.*\)$', '}', 'g')
            if endbrace == '}'
                let text .= substitute(line, '^[ \t]*}\(.*\)$', '...}\1', 'g')
            endif
        endif
    endif
    let foldlen = v:foldend - v:foldstart + 1
    let percent = printf("[%.1f", (foldlen * 1.0)/line('$') * 100) . "%] "
    let info    = " " . foldlen . " lines " . percent . repeat('+--', v:foldlevel) . '|'
    let text   .= repeat(' ', 100)
    let sign_w  = empty(quickfixsigns#marks#GetList('%')) ? 0 : 2
    let len     = min([winwidth(0) - (&number * &numberwidth) - &foldcolumn - sign_w, 100])
    let text    = strpart(text, 0, len - strlen(info))
    return text . info
endfunction

" GenerateTabLine() {{{2
if exists("+showtabline")
    function! GenerateTabLine()
        let s = ''
        let t = tabpagenr()
        let i = 1
        while i <= tabpagenr('$')
            let buflist = tabpagebuflist(i)
            let winnr = tabpagewinnr(i)
            let s .= '%' . i . 'T'
            let s .= (i == t ? '%5*' : '%4*')
            let s .= ' '
            let s .= i . ':'
"            let s .= winnr . '/' . tabpagewinnr(i,'$')
            let s .= tabpagewinnr(i,'$')
            let mod = '%6*'
            let j = 1
            while j <= tabpagewinnr(i,'$')
                if getbufvar(buflist[j - 1], "&modified") != 0
                    let mod .= '%#StatusLineModFlag#*'
                    break
                endif
                let j = j + 1
            endwhile
            let s .= mod
            let s .= ' %*'
            let s .= (i == t ? '%#TabLineSel#' : '%#TabLine#')
            let file = bufname(buflist[winnr - 1])
            let file = fnamemodify(file, ':p:t')
            if file == ''
                let file = '[No Name]'
            endif
            let s .= file
"            let s .= file . ' '
            let i = i + 1
        endwhile
        let s .= '%T%#TabLineFill#%='
        let s .= (tabpagenr('$') > 1 ? '%999XX' : 'X')
        return s
    endfunction
"    set stal=2
endif

" GenCscopeAndTags() {{{2
function! GenCscopeAndTags()
    " see ~/.ctags
    if g:ctagsbin == ''
        echomsg 'No ctags found!'
        return
    endif
    let ctagsbin = g:ctagsbin
    let userdefs = tagbar#getusertypes()
    for type in values(userdefs)
        if has_key(type, 'deffile')
            let ctagsbin .= ' --options=' . expand(type.deffile)
        endif
    endfor

    if filereadable("cscope.files")
        execute '!cscope -qbc'
        execute '!' . ctagsbin . ' -L cscope.files'
    else
        execute '!cscope -Rqbc'
        execute '!' . ctagsbin . ' -R'
    endif
    if filereadable('cscope.out')
        if cscope_connection(2, "cscope.out") == 0
            execute 'cs add cscope.out'
        else
            execute 'cs reset'
        endif
    endif
"    execute 'CCTreeLoadDB cscope.out'
endfunction

" InsertGuards() {{{2
function! InsertGuards()
    let guardname = "_" . substitute(toupper(expand("%:t")), "[\\.-]", "_", "g") . "_"
    execute "normal! ggI#ifndef " . guardname
    execute "normal! o#define " . guardname . " "
    execute "normal! Go#endif /* " . guardname . " */"
    normal! kk
endfunction

" LoadLocalVimrcs() {{{2
function! LoadLocalVimrcs()
    let configs = reverse(findfile('.vimrc.local', '.;', -1))
    for config in configs
        if filereadable(config)
"            execute 'sandbox source ' . config
            execute 'source ' . config
        endif
    endfor
endfunction
autocmd vimrc BufNewFile,BufReadPost * call LoadLocalVimrcs()

" QfDo() {{{2
" http://stackoverflow.com/questions/4792561/how-to-do-search-replace-with-ack-in-vim
" http://vimcasts.org/episodes/project-wide-find-and-replace/
command! -nargs=+ QfDo call QfDo(<q-args>)
function! QfDo(command)
    " Create a dictionary so that we can get the list of buffers rather than
    " the list of lines in buffers (easy way to get unique entries)
    let buffer_numbers = {}
    " For each entry, use the buffer number as a dictionary key (won't get
    " repeats)
    for fixlist_entry in getqflist()
        let buffer_numbers[fixlist_entry.bufnr] = 1
    endfor

    for buf in keys(buffer_numbers)
        execute 'buffer' buf
        execute a:command
        update
    endfor
endfunction

" Qf2Args() {{{2
" Source: https://github.com/jszakmeister/vimfiles/blob/master/vimrc
function! s:Qf2Args()
    let files = {}
    silent! argdelete *
    for lines in getqflist()
        if lines.bufnr > 0
            let files[bufname(lines.bufnr)] = 1
        endif
    endfor
    for file in keys(files)
        execute "silent argadd " . file
    endfor
endfunction

command! -bar Qf2Args call s:Qf2Args()

" s:RangerChooser() {{{2
function! s:RangerChooser() abort
    let tmpfile = tempname()
    let ranger_cmd = 'ranger --choosefile=' . tmpfile . ' ' . expand('%:p:h')
    if has('gui_running')
        execute '!urxvt -geometry 140x40 -e ' . ranger_cmd
    else
        execute 'silent !' . ranger_cmd
    endif
    if filereadable(tmpfile)
        execute 'edit ' . system('cat ' . tmpfile)
        call system('rm ' . tmpfile)
    endif
    redraw!
endfunction
nnoremap <silent> ,ra :call <SID>RangerChooser()<CR>

" Redir {{{2
" Taken from
" https://github.com/jszakmeister/vimfiles/blob/master/vimrc
" Redirect to register "x":
"   Redir @x
" Redirect to global variable "v":
"   Redir => v
" Disable previous redirection (any of these):
"   Redir
"   Redir end
"   Redir END
" While redirected, the 'more' option is reset to avoid the need
" to press <Space> after each screen of output.
command! -nargs=* -bar Redir
            \ if <q-args> == "" || <q-args> ==? "end" |
            \     set more |
            \     redir END |
            \ else |
            \     redir <args> |
            \     set nomore |
            \ endif

" RunShellCommand() {{{2
function! s:RunShellCommand(cmdline)
    botright new
    setlocal buftype=nofile bufhidden=wipe nobuflisted noswapfile
    setlocal nowrap
    nmap <buffer> q :close<cr>
"    call setline(1,a:cmdline)
"    call setline(2,substitute(a:cmdline,'.','=','g'))
    if v:version >= 702
        if stridx(a:cmdline, "git") == 0
            setlocal filetype=git
        endif
    elseif stridx(a:cmdline, "diff") >= 0
        set filetype=diff
    endif
    execute 'silent 0read !'.escape(a:cmdline,'%#')
    setlocal nomodifiable
    1
endfunction

command! -complete=file -nargs=* Git   call s:RunShellCommand('git '.<q-args>)
command! -complete=file -nargs=+ Shell call s:RunShellCommand(<q-args>)

" SmartTOHtml() {{{2
"A function that inserts links & anchors on a TOhtml export.
" Notice:
" Syntax used is:
"   *> Link
"   => Anchor
function! SmartTOHtml()
    TOhtml
    try
        %s/&quot;\s\+\*&gt; \(.\+\)</" <a href="#\1" style="color: cyan">\1<\/a></g
        %s/&quot;\(-\|\s\)\+\*&gt; \(.\+\)</" \&nbsp;\&nbsp; <a href="#\2" style="color: cyan;">\2<\/a></g
        %s/&quot;\s\+=&gt; \(.\+\)</" <a name="\1" style="color: #fff">\1<\/a></g
    catch
    endtry
    exe ":write!"
    exe ":bd"
endfunction

" s:Spelllang() {{{2
function! s:Spelllang(lang) abort
    let &spelllang = a:lang
    let base = substitute(a:lang, '^\([^_]\+\).*', '\1', '')
    let &spellfile = expand('~/.vim/spell/' . base . '.utf-8.add')
endfunction
function! s:Spelllist(ArgLead, CmdLine, CursorPos) abort
    let langs = ['en_nz', 'de']
    return filter(langs, "v:val =~# '^' . a:ArgLead")
endfunction

command -nargs=1 -complete=customlist,s:Spelllist Spelllang call s:Spelllang(<q-args>)

" StripTrailing() {{{2
function! StripTrailing(pattern) abort
    let savePos = winsaveview()
    let saveFoldEnable = &foldenable
    setlocal nofoldenable
    execute '%substitute /' . a:pattern . '$//ge'
    let &l:foldenable = saveFoldEnable
    call winrestview(savePos)
endfunction
command! -bar StripTrailingWhitespace call StripTrailing('\s\+')
command! -bar StripTrailingCtrlM      call StripTrailing('<C-M>')

" Tab2Space/Space2Tab {{{2
command! -range=% -nargs=0 Tab2Space exec "<line1>,<line2>s/^\\t\\+/\\=substitute(submatch(0), '\\t', "repeat(' ', ".&ts."), 'g')"
command! -range=% -nargs=0 Space2Tab exec "<line1>,<line2>s/^\\( \\{".&ts."\\}\\)\\+/\\=substitute(submatch(0), ' \\{".&ts."\\}', '\\t', 'g')"

" TextObjectNumber() {{{2
function! s:TextObjectNumber(whole)
    normal! v

    while getline('.')[col('.')] =~# '\v[0-9.]'
        normal! l
    endwhile

    if a:whole
        normal! o

        while col('.') > 1 && getline('.')[col('.') - 2] =~# '\v[0-9.]'
            normal! h
        endwhile

        normal! o
    endif
endfunction

onoremap  N :<c-u>call <SID>TextObjectNumber(0)<cr>
xnoremap  N :<c-u>call <SID>TextObjectNumber(0)<cr>
onoremap aN :<c-u>call <SID>TextObjectNumber(1)<cr>
xnoremap aN :<c-u>call <SID>TextObjectNumber(1)<cr>
onoremap iN :<c-u>call <SID>TextObjectNumber(1)<cr>
xnoremap iN :<c-u>call <SID>TextObjectNumber(1)<cr>

" Timestamp() {{{2
function! Timestamp()
    let matchpat = '\v\C%(<Last changed\s*:\s+)\zs\d{4}-\d{2}-\d{2} (\d{2}):\d{2}:\d{2} [+-]\d{4} \a+|<TIMESTAMP>'
    let replpat  = '%Y-%m-%d %H:%M:%S %z %Z'

    for linenr in range(1, 20)
        let line   = getline(linenr)
        let matchl = matchlist(line, matchpat)
        if !empty(matchl)
            let hour = strftime('%H')
            " only update once per hour to avoid messing with the undo buffer
            " too much
            if matchl[1] != hour
                let repl    = strftime(replpat)
                let newline = substitute(line, matchpat, repl, '')
                keepjumps call setline(linenr, newline)
            endif
        endif
    endfor
endfunction
autocmd vimrc BufWritePre * call Timestamp()

" ToggleExpandTab() {{{2
function! ToggleExpandTab()
    if &sts == 4
        setlocal softtabstop=8
        setlocal shiftwidth=8
        setlocal noexpandtab
    else
        setlocal softtabstop=4
        setlocal shiftwidth=4
        setlocal expandtab
    endif
    unlet! b:statusline_tab_warning
    set expandtab?
endfunction

" ToggleFold() {{{2
" Toggle fold state between closed and opened.
" If there is no fold at current line, just moves forward.
" If it is present, reverse its state.
fun! ToggleFold()
    if foldlevel('.') == 0
        normal! l
    else
        if foldclosed('.') < 0
            . foldclose
        else
            . foldopen
        endif
    endif
    " Clear status line
    echo
endfun

" ToggleFullscreen() {{{2
function! ToggleFullscreen()
    if !executable('wmctrl')
        echoerr 'wmctrl not installed!'
        return
    endif
    silent !wmctrl -r :ACTIVE: -b toggle,fullscreen
endfunction
nnoremap <silent> <F11> :call ToggleFullscreen()<CR>

" Options {{{1

" important {{{2
set cpoptions+=$
set cpoptions-=a

" moving around, searching and patterns {{{2

" list of flags specifying which commands wrap to another line (local to window)
set whichwrap=<,>,b,s,[,]
" change to directory of file in buffer
"set autochdir

" show match for partly typed search command
set incsearch
" ignore case when using a search pattern
set ignorecase
" override 'ignorecase' when pattern has upper case characters
set smartcase

" pattern for a macro definition line (global or local to buffer)
set define=^\\(\\s*#\\s*define\\\|[a-z]*\\s*const\\s*[a-z]*\\)

" tags {{{2

" when completing tags in Insert mode show more info
set showfulltag
" use cscope for tag commands
set nocscopetag
" give messages when adding a cscope database
set cscopeverbose
" When to open a quickfix window for cscope
set cscopequickfix=s-,c-,d-,i-,t-,e-

" displaying text {{{2

" number of screen lines to show around the cursor
set scrolloff=5

" long lines wrap
set wrap
" wrap long lines at a character in 'breakat' (local to window)
set linebreak
" which characters might cause a line break
"set breakat=\ ^I
" string to put before wrapped screen lines
set showbreak=…

" include "lastline" to show the last line even if it doesn't fit
" include "uhex" to show unprintable characters as a hex number
set display=lastline
" characters to use for the status line, folds and filler lines
set fillchars=
" number of lines used for the command-line
"set cmdheight=2
" don't redraw while executing macros
set lazyredraw

" show <Tab> as ^I and end-of-line as $ (local to window)
set list
" list of strings used for list mode
set listchars=tab:»-,trail:·,nbsp:×,precedes:«,extends:»
"set listchars=tab:»-,trail:␣,nbsp:×,precedes:«,extends:»

" show the line number for each line (local to window)
set number

" syntax, highlighting and spelling {{{2

" "dark" or "light"; the background color brightness
set background=dark
" highlight all matches for the last used search pattern
set hlsearch

" highlight spelling mistakes
set nospell
" list of accepted languages
set spelllang=en_nz
" file that "zg" adds good words to
set spellfile=~/.vim/spell/en.utf-8.add
" pattern to locate the end of a sentence
set spellcapcheck=[.?!]\\_[\\])'\"\	\ ]\\+
" methods used to suggest corrections
set spellsuggest=best,10

let g:tex_comment_nospell = 1

" multiple windows {{{2

" 0, 1 or 2; when to use a status line for the last window
set laststatus=2
" alternate format to be used for a status line
"set statusline=%!GenerateStatusline()
" default height for the preview window
set previewheight=9
" don't unload a buffer when no longer shown in a window
set hidden
" "useopen" and/or "split"; which window to use when jumping to a buffer
set switchbuf=useopen " or usetab
" a new window is put below the current one
"set splitbelow

" multiple tab pages {{{2

if exists("+showtabline")
    " 0, 1 or 2; when to use a tab pages line
    set showtabline=1
    " custom tab pages line
    set tabline=%!GenerateTabLine()
endif

" terminal {{{2

" terminal connection is fast
set ttyfast
" show info in the window title
set title
" string to restore the title to when exiting Vim
let &titleold = fnamemodify(&shell, ":t")
" disable visual bell
set t_vb=

" using the mouse {{{2

" list of flags for using the mouse
set mouse=a
" "extend", "popup" or "popup_setpos"; what the right mouse button is used for
set mousemodel=popup
" "xterm", "xterm2", "dec" or "netterm"; type of mouse
set ttymouse=xterm


" printing {{{2

" list of items that control the format of :hardcopy output
set printoptions=paper:A4,left:5pc,right:5pc,top:5pc,bottom:5pc,syntax:a,number:y
" name of the font to be used for :hardcopy
set printfont=:h8

" expression used to print the PostScript file for :hardcopy
set printexpr=PrintFile(v:fname_in)
function! PrintFile(fname)
"    call system("lp " . (&printdevice == '' ? '' : ' -s -d' . &printdevice) . ' ' . a:fname)
    call system("evince " . a:fname)
    call delete(a:fname)
    return v:shell_error
endfunc

" messages and info {{{2

" list of flags to make messages shorter
set shortmess=aoOtI
" show (partial) command keys in the status line
set showcmd
" display the current mode in the status line
set showmode
" show cursor position below each window
set ruler
" pause listings when the screen is full
set more
" start a dialog when a command fails
set confirm
" use a visual bell instead of beeping
"set visualbell

" selecting text {{{2

" 'unnamed' to use the * register like unnamed register
" 'autoselect' to always put selected text into register *
set clipboard=unnamed,unnamedplus,exclude:cons\|linux

" editing text {{{2

" maximum number of changes that can be undone
set undolevels=1000
" line length above which to break a line (local to buffer)
set textwidth=78
" specifies what <BS>, CTRL-W, etc. can do in Insert mode
set backspace=indent,eol,start
" list of flags that tell how automatic formatting works (local to buffer)
set formatoptions+=r " continue comments when pressing <Enter>
set formatoptions-=o " don't continue comments when pressing o/O
set formatoptions+=n " recognize numbered lists when formatting
set formatoptions+=2 " use indent of second line in paragraph
set formatoptions+=l " don't break long lines that were already too long
if v:version > 703 || v:version == 703 && has('patch541')
    set formatoptions+=j " remove comment markers when joining lines
endif
" pattern to recognize a numbered list (local to buffer)
let &formatlistpat = '^\s*\(\d\+\|\a\)[:.)]\s*'

" specifies how Insert mode completion works for CTRL-N and CTRL-P
" (local to buffer)
set complete-=u " scan the unloaded buffers that are in the buffer list
"set complete+=k " scan the files given with the 'dictionary' option
set complete-=i " scan current and included files

" whether to use a popup menu for Insert mode completion
"set completeopt=longest,menu,preview
set completeopt=longest,menuone

" list of dictionary files for keyword completion (global or local to buffer)
set dictionary=/usr/share/dict/words

" the "~" command behaves like an operator
set tildeop
" When inserting a bracket, briefly jump to its match
set showmatch
" use two spaces after '.' when joining a line
set nojoinspaces
" "alpha", "octal" and/or "hex"; number formats recognized for CTRL-A and
" CTRL-X commands (local to buffer)
set nrformats-=octal

" tabs and indenting {{{2

" number of spaces a <Tab> in the text stands for (local to buffer)
set tabstop=8     " should always be 8
" number of spaces used for each step of (auto)indent (local to buffer)
set shiftwidth=4
" a <Tab> in an indent inserts 'shiftwidth' spaces
set smarttab      " shiftwidth at start of line, tabstop/sts elsewhere
" if non-zero, number of spaces to insert for a <Tab> (local to buffer)
" WARNING: mixes spaces and tabs if >0 and noexpandtab!
if v:version > 703 || v:version == 703 && has("patch693")
    set softtabstop=-1
else
    set softtabstop=4
endif
" round to 'shiftwidth' for "<<" and ">>"
set shiftround
" expand <Tab> to spaces in Insert mode (local to buffer)
set expandtab     " WARNING: don't unset if ts != sw

" automatically set the indent of a new line (local to buffer)
set autoindent
" do clever autoindenting (local to buffer)
" more or less deprecated in favor of cindent and indentexpr
"set smartindent

" folding {{{2

" set to display all folds open (local to window)
set nofoldenable
" folds with a level higher than this number will be closed (local to window)
"set foldlevel=100
" width of the column used to indicate folds (local to window)
"set foldcolumn=3
" expression used to display the text of a closed fold
set foldtext=GenerateFoldText()
" specifies for which commands a fold will be opened
set foldopen=block,hor,insert,jump,mark,percent,quickfix,search,tag,undo
" maximum fold depth for when 'foldmethod is "indent" or "syntax" (local to window)
set foldnestmax=2

let g:vimsyn_folding = 'afmpPrt'

" diff mode {{{2

" options for using diff mode
set diffopt=filler,vertical

" mapping {{{2
" allow timing out halfway into a mapping
set timeout
" allow timing out halfway into a key code
set nottimeout
" time in msec for 'timeout'
set timeoutlen=1000
" time in msec for 'ttimeout'
set ttimeoutlen=10

" reading and writing files {{{2

" enable using settings from modelines when reading a file (local to buffer)
set modeline
" number of lines to check for modelines
set modelines=5
" list of file formats to look for when editing a file
set fileformats=unix,dos,mac

" keep a backup after overwriting a file
"set backup
" list of directories to put backup files in
"set backupdir= " where to put backup files

" automatically read a file when it was modified outside of Vim
" (global or local to buffer)
set autoread

" keep oldest version of a file; specifies file name extension
"set patchmode=.orig

" the swap file {{{2

" list of directories for the swap file
let &directory = expand("$HOME/.cache/vim/swap//")
" number of characters typed to cause a swap file update
set updatecount=100
" time in msec after which the swap file will be updated
set updatetime=2000

" command line editing {{{2

" how many command lines are remembered
set history=100

" specifies how command line completion works
set wildmode=list:longest,full
" list of file name extensions that have a lower priority
set suffixes=.pdf,.bak,~,.info,.log,.bbl,.blg,.brf,.cb,.ind,.ilg,.inx,.nav,.snm,.out
" list of file name extensions added when searching for a file (local to buffer)
set suffixesadd=.rb
" list of patterns to ignore files for file name completion
set wildignore=tags,*.o,CVS,.svn,.git,*.aux,*.sw[po],*.idx,*.hi,*.dvi,*.lof,*.lol,*.toc,*.class,*.zwc,obj*/**,target/**
" ignore case when completing file names
set wildignorecase
" command-line completion shows a list of matches
"set wildmenu
" key used to open the command-line window
set cedit=<C-O>

" running make and jumping to errors {{{2

" program used for the ":grep" command (global or local to buffer)
if executable('ag')
    set grepprg=ag\ --nogroup\ --nocolor\ --column\ --smart-case
    set grepformat^=%f:%l:%c:%m
else
    set grepprg=ack
endif

" language specific {{{2

" Avoid command-line redraw on every entered character by turning off Arabic
" shaping (which is implemented poorly).
if has('arabic')
    set noarabicshape
endif

" multi-byte characters {{{2

" automatically detected character encodings
set fileencodings=ucs-bom,utf-8,default,latin1

" various {{{2

filetype plugin indent on
syntax enable

let g:CSApprox_attr_map = { 'bold' : 'bold', 'italic' : '', 'sp' : 'fg' }
" must come after terminal color configuration
if !has('gui') && v:version < 703
    colorscheme desert256
else
    colorscheme desert
endif

" when to use virtual editing: "block", "insert" and/or "all"
set virtualedit=all
" list of words that specifies what to put in a session file
set sessionoptions=blank,buffers,curdir,folds,help,slash,tabpages,unix,winsize
" list that specifies what to write in the viminfo file
set viminfo=!,'20,<50,h,r/tmp,r/mnt,r/media,s50,n~/.cache/vim/viminfo

" see ft-tex-plugin
let g:tex_flavor = "latex"

" see ft-sh-syntax
let g:is_bash = 1

let g:python_highlight_all = 1

" Highlight conflict markers
match ErrorMsg '^\(<\|=\|>\)\{7\}\([^=].\+\)\?$'

" Plugin and script options {{{1

" bufexplorer {{{2
let g:bufExplorerDisableDefaultKeyMapping=1    " Disable mapping.
nnoremap <silent> <leader>be :BufExplorer<CR>

" calendar.vim {{{2
let g:calendar_no_mappings = 1

" cecutil.vim {{{2
call s:fakemap('<Plug>RestoreWinPosn')
call s:fakemap('<Plug>SaveWinPosn')

" changelog {{{2
let g:changelog_username = "Jan Larres <jan@majutsushi.net>"

" CheckAttach {{{2
let g:attach_check_keywords  = '.doc,.pdf,.xls,.ppt,.rtf,.pps'
let g:attach_check_keywords .= ',attachment,attach,attached,attaching,enclosed'
let g:attach_check_keywords .= ',anhängen,angehängt,Anhang'
let g:attach_check_keywords .= ',CV,resume,cover letter'
let g:checkattach_filebrowser = 'ranger'

" clang_complete {{{2
let g:clang_auto_select = 1
let g:clang_use_library = 1

" code_complete {{{2
let g:completekey = "<c-tab>"

" command-t {{{2
let g:CommandTMaxFiles = 100000
let g:CommandTMatchWindowReverse = 1

" ConqueTerm {{{2
let g:ConqueTerm_StartMessages = 0

" CSApprox {{{2
let g:CSApprox_attr_map = {'sp': 'fg'}

let g:CSApprox_hook_desert_post = [
    \ 'hi DiffAdd ctermbg=28',
    \ 'hi DiffDelete ctermbg=88 ctermfg=88',
\]

" Ctrl-P {{{2
let g:ctrlp_map = '<leader>ff'
let g:ctrlp_cmd = 'CtrlP'
let g:ctrlp_match_func = {'match' : 'matcher#cmatch' }
nnoremap <silent> <leader>bb :CtrlPBuffer<CR>
nnoremap <silent> <leader>ft :CtrlPBufTag<CR>

let g:ctrlp_working_path_mode = 'a'
let g:ctrlp_prompt_mappings = {
    \ 'PrtBS()'      : ['<bs>', '<c-]>', '<c-h>'],
    \ 'PrtCurLeft()' : ['<left>', '<c-^>'],
\ }
let g:ctrlp_cache_dir = $HOME . '/.cache/ctrlp'
let g:ctrlp_mruf_exclude = '/tmp/.*'
let g:ctrlp_custom_ignore = {
    \ 'dir':  '\.git$\|\.hg$\|\.svn$',
    \ 'file': '\.exe$\|\.so$\|\.dll$',
\ }
let g:ctrlp_max_files = 0
let g:ctrlp_user_command = {
    \ 'types': {
        \ 1: ['.git/', 'cd %s && git ls-files -oc --exclude-standard'],
        \ 2: ['.hg/', 'hg --cwd %s locate -I .'],
    \ },
    \ 'fallback': 'find %s -type f'
\ }
let g:ctrlp_open_new_file = 'r'
let g:ctrlp_lazy_update = 0
let g:ctrlp_mruf_relative = 0
let g:ctrlp_extensions = ['tag', 'buffertag', 'quickfix', 'dir', 'rtscript']

let g:ctrlp_buftag_types = {
    \ 'grace' : '--options=' . $HOME . '/.vim/bundle/vim-grace/ctags/grace.cnf --language-force=grace --grace-types=idvtcm'
\ }

" devhelp {{{2
let g:devhelpSearch = 1
let g:devhelpAssistant = 0
let g:devhelpSearchKey = '<F7>'
let g:devhelpWordLength = 5

" DrawIt {{{2
call s:fakemap('<Plug>DrawItStart')
call s:fakemap('<Plug>DrawItStop')

" EasyMotion {{{2
let g:EasyMotion_do_mapping = 0
let g:EasyMotion_keys = 'asdfghjkl;qwertyuiopzxcvbnm/'
nmap s <Plug>(easymotion-s2)
xmap s <Plug>(easymotion-s2)
omap z <Plug>(easymotion-s2)

nmap f <Plug>(easymotion-fl)
nmap F <Plug>(easymotion-Fl)
xmap f <Plug>(easymotion-fl)
xmap F <Plug>(easymotion-Fl)
omap f <Plug>(easymotion-fl)
omap F <Plug>(easymotion-Fl)
nmap t <Plug>(easymotion-tl)
nmap T <Plug>(easymotion-Tl)
xmap t <Plug>(easymotion-tl)
xmap T <Plug>(easymotion-Tl)
omap t <Plug>(easymotion-tl)
omap T <Plug>(easymotion-Tl)

" map  / <Plug>(easymotion-sn)
" omap / <Plug>(easymotion-tn)
" map  n <Plug>(easymotion-next)
" map  N <Plug>(easymotion-prev)

" Eclim {{{2
let g:EclimLoggingDisabled = 1
let g:EclimCompletionMethod = 'omnifunc'

" expand-region {{{2
nmap <C-Space> <Plug>(expand_region_expand)
xmap <C-Space> <Plug>(expand_region_expand)
xmap _         <Plug>(expand_region_shrink)

let g:expand_region_text_objects = {
    \ 'iw'  : 0,
    \ 'iW'  : 0,
    \ 'i"'  : 0,
    \ 'i''' : 0,
    \ 'i]'  : 1,
    \ 'ib'  : 1,
    \ 'iB'  : 1,
    \ 'il'  : 0,
    \ 'ip'  : 0,
    \ 'ie'  : 0,
    \ 'if'  : 1,
    \ 'af'  : 1,
\ }

" FSwitch {{{2
nnoremap <silent> go :FSHere<cr>

augroup vimrc
    autocmd BufEnter *.c        let b:fswitchdst  = 'h'
    autocmd BufEnter *.c        let b:fswitchlocs = './'
    autocmd BufEnter *.cpp,*.cc let b:fswitchdst  = 'h,hpp'
    autocmd BufEnter *.cpp,*.cc let b:fswitchlocs = './'
    autocmd BufEnter *.h        let b:fswitchdst  = 'cpp,cc,c'
    autocmd BufEnter *.h        let b:fswitchlocs = './'
augroup END

" Fugitive {{{2
" automatically delete fugitive buffers when leaving them
autocmd vimrc BufReadPost fugitive://* set bufhidden=delete

" gitgutter {{{2
let g:gitgutter_map_keys = 0
let g:gitgutter_escape_grep = 1

nmap [c <Plug>GitGutterPrevHunk
nmap ]c <Plug>GitGutterNextHunk

highlight GitGutterAdd          gui=bold guifg=#11ee11
highlight GitGutterDelete       gui=bold guifg=#ee1111
highlight GitGutterChange       gui=bold guifg=#eeee11
highlight GitGutterChangeDelete gui=bold guifg=#eeee11

" Gitv {{{2
let g:Gitv_OpenHorizontal = 1

" GnuPG {{{2
let g:GPGUsePipes = 1

" Jedi {{{2
let g:jedi#auto_vim_configuration = 0

" Latex Box {{{2
let g:LatexBox_completion_close_braces = 0
"let g:LatexBox_latexmk_options = "-pvc"
let g:LatexBox_autojump = 1

" Mark {{{2
nmap gmm <Plug>MarkSet
xmap gmm <Plug>MarkSet
nmap gmr <Plug>MarkRegex
xmap gmr <Plug>MarkRegex
nmap gmn <Plug>MarkClear
nmap gm* <Plug>MarkSearchCurrentNext
nmap gm# <Plug>MarkSearchCurrentPrev
nmap gm/ <Plug>MarkSearchAnyNext
nmap gm? <Plug>MarkSearchAnyPrev

" NERD_Tree {{{2
let NERDTreeMinimalUI = 1
let NERDTreeDirArrows = 1
"let NERDTreeCaseSensitiveSort = 1
let NERDTreeChDirMode = 2 " change pwd with nerdtree root change
let NERDTreeHijackNetrw = 0
let NERDTreeIgnore = [
    \ '\~$',
    \ '\.o$',
    \ '\.swp$',
    \ '\.bbl$',
    \ '\.blg$',
    \ '\.fdb_latexmk$',
    \ '\.log$',
    \ '\.out$',
    \ '\.pdf$'
\ ]

autocmd vimrc BufEnter * if (winnr("$") == 1 && exists("b:NERDTreeType") && b:NERDTreeType == "primary") | q | endif

" s:toggle_nerdtree() {{{3
function! s:toggle_nerdtree() abort
    if exists('t:NERDTreeBufName')
        let nerdtree_open = bufwinnr(t:NERDTreeBufName) != -1
    else
        let nerdtree_open = 0
    endif

    if nerdtree_open
        NERDTreeClose
    else
        NERDTreeFind
    endif
endfunction
" }}}3

nnoremap <silent> <M-n>      :call <SID>toggle_nerdtree()<CR>
nnoremap <silent> <F10>      :NERDTreeToggle<CR>

" netrw {{{2
" Taken from https://github.com/jszakmeister/vimfiles/blob/master/vimrc

" Setup xdg-open as the tool to open urls whenever we can, if nothing is set up.
" This makes using 'gx' a little more sane environments outside of Gnome and
" KDE.
function! SetupBrowseX()
    if !exists("g:netrw_browsex_viewer") && executable("xdg-open")
        let g:netrw_browsex_viewer = "xdg-open"
    endif
endfunction

augroup local_netrw
    autocmd!
    autocmd VimEnter * call SetupBrowseX()
augroup END

" Get selected text in visual mode. Taken from xolox's answer in
" <http://stackoverflow.com/a/6271254/683080>.
function! s:GetSelectedText()
    let [lnum1, col1] = getpos("'<")[1:2]
    let [lnum2, col2] = getpos("'>")[1:2]
    let lines = getline(lnum1, lnum2)
    let lines[-1] = lines[-1][: col2 - (&selection == 'inclusive' ? 1 : 2)]
    let lines[0] = lines[0][col1 - 1:]
    return join(lines, "\n")
endfunction

if has("python") || has("python3")
" Turn off netrw's gx.
    let g:netrw_nogx = 1

    function! ExtractUrl(text)
    python << endpython
import re
text = vim.eval("a:text")
vim.command("let l:result = ''")

# Regex from:
# <http://daringfireball.net/2010/07/improved_regex_for_matching_urls>
# Updated version:
# <https://gist.github.com/gruber/249502/>
urlRe = re.compile(
    ur"(?i)\b("
    ur"(?:[a-z][\w-]+:(?:/{1,3}|[a-z0-9%])|www\d{0,3}[.]|"
        ur"[a-z0-9.\-]+[.][a-z]{2,4}/)"
    ur"(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+"
    ur"(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|"
        ur"""[^\s`!()\[\]{};:'".,<>?\u00AB\u00BB\u201C\u201D\u2018\u2019])"""
    ur")")

m = urlRe.search(text)
if m:
    vim.command("let l:result = '" + m.group(1).replace("'", "''") + "'")
endpython

        return l:result
    endfunction

    function! s:SmartOpen(mode) range
        if a:mode ==# 'n'
            let uri = ExtractUrl(expand("<cWORD>"))
            if l:uri == ""
                return
            endif
        else
            let uri = s:GetSelectedText()
        endif

        call netrw#NetrwBrowseX(l:uri, 0)
    endfunction

    nnoremap gx :call <SID>SmartOpen('n')<CR>
    xnoremap gx <C-C>:call <SID>SmartOpen('v')<CR>
endif

" ProtoDef {{{2
let g:protodefprotogetter = expand('~/.vim/bundle/protodef/pullproto.pl')
let g:protodefctagsexe = g:ctagsbin

" Quickfixsigns {{{2
let g:quickfixsigns_classes = ['qfl', 'loc', 'marks', 'breakpoints']
let g:quickfixsigns_blacklist_buffer = '\v(^__.*__$)|(^NERD_tree.*)|(^$)'
let g:quickfixsigns_icons = {}
" exclude "'." from buffer and "<>^" from global
let g:quickfixsigns#marks#buffer = split('abcdefghijklmnopqrstuvwxyz', '\zs')
let g:quickfixsigns#marks#global = split('ABCDEFGHIJKLMNOPQRSTUVWXYZ', '\zs')
let g:quickfixsigns#vcsdiff#highlight = {'ADD' : 'QFS_ADD',
                                       \ 'DEL' : 'QFS_DEL',
                                       \ 'CHANGE' : 'QFS_CHANGE'}

highlight QFS_ADD    guifg=#009900 guibg=NONE
highlight QFS_DEL    guifg=#bbbb00 guibg=NONE
highlight QFS_CHANGE guifg=#ff2222 guibg=NONE

" r-plugin {{{2
if executable('urxvt')
    let vimrplugin_term_cmd = "urxvt -title R -e"
else
    let vimrplugin_term = "uxterm"
endif
let vimrplugin_conqueplugin = 1
let vimrplugin_conquevsplit = 1
let vimrplugin_underscore   = 0

" Screen {{{2
let g:ScreenImpl = 'Tmux'
let g:ScreenShellTerminal = 'urxvt'
let g:ScreenShellExpandTabs = 1

function! s:ScreenShellListener()
    if g:ScreenShellActive
        nnoremap <silent> <leader>ss :ScreenSend<cr>
        xnoremap <silent> <leader>ss :ScreenSend<cr>
        nnoremap <silent> <leader>sq :ScreenQuit<cr>
    else
        nnoremap <silent> <leader>ss :ScreenShellVertical<cr>
    endif
endfunction

nnoremap <silent> <leader>ss :ScreenShellVertical<cr>
augroup ScreenShellEnter
    autocmd!
    autocmd User * call <SID>ScreenShellListener()
augroup END
augroup ScreenShellExit
    autocmd!
    autocmd User * call <SID>ScreenShellListener()
augroup END

" Sneak {{{2
" let g:sneak#streak = 1
" let g:sneak#s_next = 0

" highlight SneakPluginTarget guifg=#f5deb3 guibg=#cd853f gui=bold
" highlight SneakStreakTarget guifg=#f5deb3 guibg=#cd853f gui=bold
" highlight SneakStreakMask guifg=#cd853f guibg=#cd853f

" nnoremap <silent> f      :<c-u>call sneak#wrap('', 1, 0, 1, 0)<CR>
" nnoremap <silent> F      :<c-u>call sneak#wrap('', 1, 1, 1, 0)<CR>
" xnoremap <silent> f <Esc>:<C-u>call sneak#wrap(visualmode(), 1, 0, 1, 1)<CR>
" xnoremap <silent> F <Esc>:<C-u>call sneak#wrap(visualmode(), 1, 1, 1, 1)<CR>
" onoremap <silent> f      :<C-u>call sneak#wrap(v:operator, 1, 0, 1, 1)<CR>
" onoremap <silent> F      :<C-u>call sneak#wrap(v:operator, 1, 1, 1, 1)<CR>

" nnoremap <silent> t      :<c-u>call sneak#wrap('', 1, 0, 0, 0)<CR>
" nnoremap <silent> T      :<c-u>call sneak#wrap('', 1, 1, 0, 0)<CR>
" xnoremap <silent> t <Esc>:<C-u>call sneak#wrap(visualmode(), 1, 0, 0, 1)<CR>
" xnoremap <silent> T <Esc>:<C-u>call sneak#wrap(visualmode(), 1, 1, 0, 1)<CR>
" onoremap <silent> t      :<C-u>call sneak#wrap(v:operator, 1, 0, 0, 1)<CR>
" onoremap <silent> T      :<C-u>call sneak#wrap(v:operator, 1, 1, 0, 1)<CR>

" Splice {{{2
let g:splice_prefix = '_'
let g:splice_initial_diff_grid = 1
let g:splice_initial_diff_compare = 1
let g:splice_initial_scrollbind_grid = 1
let g:splice_initial_scrollbind_compare = 1
let g:splice_initial_scrollbind_path = 1

" Tagbar {{{2
let g:tagbar_ctags_bin = g:ctagsbin
let g:tagbar_compact = 1

" let g:tagbar_type_tex = {
"     \ 'ctagstype' : 'latex',
"     \ 'kinds'     : [
"         \ 's:sections',
"         \ 'g:graphics:0:0',
"         \ 'l:labels',
"         \ 'r:refs:1:0',
"         \ 'p:pagerefs:1:0'
"     \ ],
"     \ 'sort' : 0
" \ }
let g:tagbar_type_idl = {
    \ 'ctagstype' : 'xpidl',
    \ 'kinds'     : [
        \ 'p:prototypes',
        \ 'i:interfaces',
        \ 'a:attributes',
        \ 't:types',
        \ 'o:operations'
    \ ]
\ }

highlight link TagbarHighlight Cursor
highlight TagbarSignature guifg=yellowgreen
highlight TagbarVisibilityPublic guifg=#11ee11
highlight TagbarVisibilityProtected guifg=SkyBlue
highlight TagbarVisibilityPrivate guifg=#ee1111

nmap <silent> <M-t> :TagbarOpenAutoClose<CR>
nmap <silent>  <F9> :TagbarToggle<CR>

" TOhtml syntax script {{{2
let html_use_css = 1
let html_number_lines = 0
let use_xhtml = 1
let html_ignore_folding = 1

" UltiSnips {{{2
let g:UltiSnipsExpandTrigger = "<C-l>"
let g:UltiSnipsJumpForwardTrigger = "<C-j>"
let g:UltiSnipsJumpBackwardTrigger = "<C-k>"
let g:UltiSnipsListSnippets = "<C-h>"
let g:UltiSnipsSnippetsDir = "~/.vim/UltiSnips"
let g:snips_author = 'Jan Larres <jan@majutsushi.net>'

" UTL {{{2
let g:utl_cfg_hdl_scm_http_system = "silent !xdg-open '%u'"

function! Utl_AddressScheme_mutt(uri, fragment, dispMode)
    let delimit = stridx(a:uri, ':')
    let mid     = strpart(a:uri, delimit + 1)

    if $TERM =~# 'screen'
        let cmd = 'screen '
    elseif executable('urxvt')
        let cmd = 'urxvt -e '
    else
        let cmd = 'xterm -e '
    endif

    let cmd .= expand('~/.etc/bin/mutt-open') . ' ' . mid
    call system(cmd)

    return []
endfunction

" vertical-move {{{2
let g:vertical_move_default_mapping = 0
nmap <silent> gj <Plug>(vertical_move_down)
nmap <silent> gk <Plug>(vertical_move_up)
xmap <silent> gj <Plug>(vertical_move_down)
xmap <silent> gk <Plug>(vertical_move_up)

" voom {{{2
let g:voom_tab_key = '<C-Tab>'
let g:voom_verify_oop = 1
let g:voom_user_command = "runtime! voom_addons/*.vim"

" ZoomWin {{{2
let g:zoomwin_stl = ''
function! ZWStatusline(zoomed)
    let g:zoomwin_stl = a:zoomed ? 'Z' : ''
endfunction
if !exists("g:ZoomWin_funcref")
    let g:ZoomWin_funcref = function("ZWStatusline")
endif

" Abbrevs {{{1
func! Eatchar(pat)
    let c = nr2char(getchar(0))
    return (c =~ a:pat) ? '' : c
endfunc

iab _me Jan Larres
iab _mail jan@majutsushi.net
iab _www http://majutsushi.net

" Correcting those typos.
iab alos also
iab aslo also
iab charcter character
iab charcters characters
iab exmaple example
iab shoudl should
iab seperate separate
iab teh the

iab _ae ä
iab _ue ü
iab _oe ö
iab _ss ß

iab _mfg  Mit freundlichen Grüßen
iab _mfgl Mit freundlichen Grüßen,Jan Larres<C-R>=Eatchar('\s')<CR>
iab _vg Viele Grüße

iab _time <C-R>=strftime("%H:%M")<CR>
" Example: 14:28

iab _date <C-R>=strftime("%a %d %b %Y %T %Z")<CR>
" Example: Di 06 Jun 2006 21:27:59 CEST

if filereadable('~/.vim/abbrevs.vim')
    source ~/.vim/abbrevs.vim
endif

" Terminal stuff {{{1

" s:MapMetaChars() {{{2
function! s:MapMetaChars() abort
    let metachars  = '0123456789'
    let metachars .= 'abcdefghijklmnopqrstuvwxyz'
    let metachars .= 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
    let metachars .= '+-='

    for char in split(metachars, '\zs')
        execute "set <M-" . char . ">=\e" . char
    endfor
endfunction "}}}2

" s:MapExtraKeys() {{{2
function! s:MapExtraKeys() abort
    " Some key combinations aren't recognized keycodes, therefore we have to
    " do this: http://vim.wikia.com/wiki/Mapping_fast_keycodes_in_terminal_Vim
    let extramaps = {
        \ 'S-CR'    : 'Q13;2~',
        \ 'C-CR'    : 'Q13;5~',
        \ 'C-S-CR'  : 'Q13;6~',
        \ 'C-Space' : 'Q32;5~',
        \ 'M->'     : '>',
        \ 'M-<'     : '<'
    \ }
    if &term =~ '^xterm\|screen'
        let extramaps['C-Insert'] = '[2;5~'
    elseif &term =~ '^rxvt-unicode'
        let extramaps['C-Insert'] = '[2^'
    endif

    let mapc = 0
    for [key, val] in items(extramaps)
        if mapc == 50
            echohl WarningMsg
            echomsg "Unable to map " . key . ": out of spare keycodes"
            echohl None
            break
        endif
        let vkey = (mapc / 25 == 0 ? '' : 'S-') . 'F' . (13 + mapc % 25)
        execute "set  <" . vkey . ">=\e" . val
        execute "map  <" . vkey . "> <" . key . ">"
        execute "map! <" . vkey . "> <" . key . ">"
        let mapc += 1
    endfor
endfunction "}}}2

if &term =~ '^rxvt-unicode\|xterm\|screen'
    " see ~/.Xresources and ':h xterm-modifier-keys'
    execute "set <xUp>=\e[1;*A"
    execute "set <xDown>=\e[1;*B"
    execute "set <xRight>=\e[1;*C"
    execute "set <xLeft>=\e[1;*D"

    execute "set <PageUp>=\e[5;*~"
    execute "set <PageDown>=\e[6;*~"

    if &term =~ '^rxvt-unicode\|screen'
        execute "set <xF1>=\e[1;*P"
        execute "set <xF2>=\e[1;*Q"
        execute "set <xF3>=\e[1;*R"
        execute "set <xF4>=\e[1;*S"
    elseif $COLORTERM == 'gnome-terminal'
        execute "set <F1>=\eO1;*P"
        execute "set <F2>=\eO1;*Q"
        execute "set <F3>=\eO1;*R"
        execute "set <F4>=\eO1;*S"
    else " xterm; for some reason t_kf1 etc. get assigned to <xF1> etc.
        execute "set <F1>=\e[1;*P"
        execute "set <F2>=\e[1;*Q"
        execute "set <F3>=\e[1;*R"
        execute "set <F4>=\e[1;*S"
    endif

    execute "set <F5>=\e[15;*~"
    execute "set <F6>=\e[17;*~"
    execute "set <F7>=\e[18;*~"
    execute "set <F8>=\e[19;*~"
    execute "set <F9>=\e[20;*~"
    execute "set <F10>=\e[21;*~"
    execute "set <F11>=\e[23;*~"
    execute "set <F12>=\e[24;*~"

    call s:MapMetaChars()

    call s:MapExtraKeys()
endif

if &term =~ '^rxvt-unicode' || $ORIGTERM =~ '^rxvt-unicode'
    set termbidi
endif

" Allow color schemes to do bright colors without forcing bold.
if &t_Co == 8 && $TERM !~# '^linux'
    set t_Co=16
endif


" Show current file in xterm title
" idea from http://ft.bewatermyfriend.org/comp/vim/vimrc.html
function! s:get_screen_title() abort
    let title = 'vim'
    let file  = expand('%:t')
    if file != ''
        if len(file) > 15
            let file = file[:13] . '…'
        endif
        let title .= '(' . file . ')'
    endif
    if !empty($SSH_CLIENT)
        let title .= '@' . substitute(system('hostname'), '\..*', '', '')
    endif
    return title
endfunction

if &term =~ '^xterm\|rxvt\|screen'
    let &t_ts = "\<Esc>]0;"
    let &t_fs = "\<Esc>\\"
    autocmd vimrc BufEnter * let &titlestring = s:get_screen_title()
endif


" Change cursor colour or shape in insert mode
" Some ideas from https://github.com/jszakmeister/vim-togglecursor
" tmux will only forward escape sequences to the terminal if surrounded by a DCS sequence
" http://sourceforge.net/mailarchive/forum.php?thread_name=AANLkTinkbdoZ8eNR1X2UobLTeww1jFrvfJxTMfKSq-L%2B%40mail.gmail.com&forum_name=tmux-users
let s:terminal = ''
if exists('$TERM_PROGRAM') && $TERM_PROGRAM == 'iTerm.app'
    let s:terminal = 'iterm'
elseif $ORIGTERM =~ '^rxvt-unicode' || $XTERM_VERSION != ''
    let s:terminal = 'xterm'
endif

let s:xterm_normal = "\e]12;yellow\e\\"
let s:xterm_insert = "\e]12;red\e\\"
let s:iterm_normal = "\e]50;CursorShape=0\x7"
let s:iterm_insert = "\e]50;CursorShape=1\x7"

function! s:tmux_escape(code) abort
    let code = substitute(a:code, "\e", "\e\e", 'g')
    return "\ePtmux;" . code . "\e\\"
endfunction

function! s:get_escape(mode) abort
    if s:terminal == ''
        return ''
    endif

    let code = s:{s:terminal}_{a:mode}

    if exists('$TMUX')
        let code = s:tmux_escape(code)
    endif

    return code
endfunction

let &t_SI = s:get_escape('insert')
let &t_EI = s:get_escape('normal')
let &t_te = s:get_escape('normal') . &t_te

" Mappings {{{1

" Readline behaviour {{{2
" Mostly taken from
" https://github.com/tpope/vim-rsi/blob/master/plugin/rsi.vim
inoremap        <C-a> <C-o>^
inoremap   <C-x><C-a> <C-a>
cnoremap        <C-a> <Home>
cnoremap   <C-x><C-a> <C-a>

inoremap <expr> <C-b> getline('.')=~'^\s*$'&&col('.')>strlen(getline('.'))?"0\<Lt>C-d>\<Lt>Esc>kJs":"\<Lt>Left>"
cnoremap        <C-b> <Left>

inoremap <expr> <C-d> col('.')>strlen(getline('.'))?"\<Lt>C-d>":"\<Lt>Del>"
cnoremap <expr> <C-d> getcmdpos()>strlen(getcmdline())?"\<Lt>C-d>":"\<Lt>Del>"

inoremap <expr> <C-e> col('.')>strlen(getline('.'))\|\|pumvisible()?"\<Lt>C-e>":"\<Lt>End>"

inoremap <expr> <C-f> col('.')>strlen(getline('.'))?"\<Lt>C-f>":"\<Lt>Right>"
cnoremap <expr> <C-f> getcmdpos()>strlen(getcmdline())?&cedit:"\<Lt>Right>"

noremap! <M-b> <S-Left>
noremap! <M-d> <C-O>dw
cnoremap <M-d> <S-Right><C-W>
noremap! <M-BS> <C-W>
noremap! <M-f> <S-Right>
noremap! <M-n> <Down>
noremap! <M-p> <Up>

" Buffers/Files/Tabs {{{2

" Fast open a buffer by searching for a name
" nnoremap <leader>b :buffers<CR>:buffer<space>

nnoremap <M-Left>  :tabprevious<CR>
nnoremap <M-Right> :tabnext<CR>

" delete buffer and close window
nnoremap   <F8> :bd<cr>
" delete buffer, but keep window
nnoremap <S-F8> :call Bclose()<cr>

" change tabs fast
nnoremap <M-1> 1gt
nnoremap <M-2> 2gt
nnoremap <M-3> 3gt
nnoremap <M-4> 4gt
nnoremap <M-5> 5gt
nnoremap <M-6> 6gt
nnoremap <M-7> 7gt
nnoremap <M-8> 8gt
nnoremap <M-9> 9gt

nnoremap <C-W>e :enew<CR>

nnoremap <leader>v :edit ~/.etc/vim/vimrc<CR>

" Text manipulation {{{2

" Control-Space for omnicomplete
imap <C-Space> <C-X><C-O>

" for popup-menu completion
" http://vim.wikia.com/wiki/Make_Vim_completion_popup_menu_work_just_like_in_an_IDE
" inoremap <expr> <C-x><C-o> pumvisible() ? '<C-x><C-o>' : '<C-x><C-o><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
" inoremap <expr> <C-n>      pumvisible() ? '<C-n>' : '<C-n><C-r>=pumvisible() ? "\<lt>Down>" : ""<CR>'
" http://vim.wikia.com/wiki/Improve_completion_popup_menu
" inoremap <expr> <Esc>      pumvisible() ? "\<C-E>" : "\<Esc>"
if v:version > 703 || v:version == 703 && has("patch489")
    inoremap <expr> <CR>       pumvisible() ? "\<C-Y>" : "\<C-]>\<CR>"
else
    inoremap <expr> <CR>       pumvisible() ? "\<C-Y>" : "\<CR>"
endif
"inoremap <expr> <Down>     pumvisible() ? "\<C-N>" : "\<Down>"
"inoremap <expr> <Up>       pumvisible() ? "\<C-P>" : "\<Up>"
inoremap <expr> <PageDown> pumvisible() ? "\<PageDown>\<C-P>\<C-N>" : "\<PageDown>"
inoremap <expr> <PageUp>   pumvisible() ? "\<PageUp>\<C-P>\<C-N>"   : "\<PageUp>"

inoremap <C-F> <C-X><C-F>

" create undo break points
inoremap <C-u> <C-g>u<C-u>
inoremap <C-w> <C-g>u<C-w>

" Uppercase word
inoremap <M-u> <Esc>gUiwea

" Swap two words
nnoremap <silent> gW :s/\(\%#\w\+\)\(\_W\+\)\(\w\+\)/\3\2\1/<CR>`'

" have Y behave analogously to D and C rather than to dd and cc (which is
" already done by yy):
nnoremap Y y$

nnoremap Q gqip

set pastetoggle=<F3>

nnoremap <S-F2> :call ToggleExpandTab()<CR>

" in/de-crease indent/autoindent what you just pasted
" https://twitter.com/dotvimrc/status/347055253318950913
nnoremap >< V`]>
nnoremap <lt>> V`]<
nnoremap =- V`]=

" copy to/from the X clipboard
nnoremap <S-Insert> "+gP
xnoremap <S-Insert> "-d"+P
inoremap <S-Insert> <C-R>+
cnoremap <S-Insert> <C-R>+
inoremap <C-Insert> <C-O>"+y
xnoremap <C-Insert> "+y
xnoremap <S-Del>    "+d
inoremap <C-Del>    <C-O>daw

nnoremap <silent> <leader>ga :GNOMEAlignArguments<CR>

" re-select selection after changing indent
xnoremap > >gv
xnoremap < <gv

inoremap <M-H> <C-d>
inoremap <M-L> <C-t>

" Move current line up or down
inoremap <M-K> <Esc>:<C-U>
            \ let oldpos = getpos('.')<CR>
            \ ddkP
            \ :<C-U>call setpos('.', oldpos)<CR>
            \ gki
inoremap <M-J> <Esc>:<C-U>
            \ let oldpos = getpos('.')<CR>
            \ ddp
            \ :<C-U>call setpos('.', oldpos)<CR>
            \ gji

" Ctrl-K comma colon (in Insert mode): UTF-8 single-codepoint ellipsis "..."
" disregard error if (for instance) not in UTF-8
if has("digraphs")
    silent! dig ,:  8230 " HORIZONTAL ELLIPSIS
    silent! dig qi 64259 " LATIN SMALL LIGATURE FFI
    silent! dig ql 64260 " LATIN SMALL LIGATURE FFL
endif

" Moving around {{{2

" make some jumps more intuitive and don't require the '{' to be in the first
" column
nnoremap <silent> [[ ?{<CR>w99[{:nohl<CR>
nnoremap <silent> ][ j0?{<CR>w99[{%/{<CR>:nohl<CR>
nnoremap <silent> ]] ][
xnoremap <silent> [[ ?{<CR>w99[{:<C-U>nohl<CR>gv
xnoremap <silent> ][ j0?{<CR>w99[{%/{<CR>:<C-U>nohl<CR>gv
xnoremap <silent> ]] ][

nnoremap ' `
nnoremap ` '

" move into wrapped lines
nnoremap j gj
nnoremap k gk
"nnoremap $ g$   " conflicts with virtualedit
"nnoremap 0 g0
"nnoremap ^ g^
xnoremap j gj
xnoremap k gk

" move around in insert mode
inoremap <M-h> <Esc>i
inoremap <M-l> <Esc>la
inoremap <M-k> <Esc>gka
inoremap <M-j> <Esc>gja

" Populate the quickfix window with the last search
nnoremap <silent> g/ :execute 'vimgrep /' . @/ . '/g %'<CR>:call qftoggle#openqfwin()<CR>

" search for visually selected text
" http://vimcasts.org/episodes/search-for-the-selected-text/
function! s:VSetSearch(cmdtype)
    let temp = @s
    normal! gv"sy
    let @/ = '\V' . substitute(escape(@s, a:cmdtype . '\'), '\n', '\\n', 'g')
    let @s = temp
endfunction

xnoremap * :<C-u>call <SID>VSetSearch('/')<CR>/<C-R>=@/<CR><CR>
xnoremap # :<C-u>call <SID>VSetSearch('?')<CR>?<C-R>=@/<CR><CR>

" substitute visual selection
xnoremap & "*y<Esc>:<c-u>%s/<c-r>=substitute(escape(@*, '\/.*$^~[]'), "\n", '\\n', "g")<cr>/

" Display {{{2

" toggle folds
nnoremap <space> :call ToggleFold()<CR>

" toggle showing 'listchars'
nnoremap <F2> :set invlist list?<CR>
imap <F2> <C-O><F2>
xmap <F2> <Esc><F2>gv

nnoremap <silent> zi
    \ :if &foldenable <Bar>
    \     setlocal nofoldenable <Bar>
    \     setlocal foldcolumn=0 <Bar>
    \ else <Bar>
    \     setlocal foldenable <Bar>
    \     setlocal foldcolumn=1 <Bar>
    \ endif<CR>

nnoremap <silent> <C-l> :if &diff <Bar> diffupdate <Bar> endif<CR>:nohlsearch<CR><C-l>

" Windows {{{2

" Easier movement between windows
nnoremap <silent> <M-h> :TmuxNavigateLeft<cr>
nnoremap <silent> <M-j> :TmuxNavigateDown<cr>
nnoremap <silent> <M-k> :TmuxNavigateUp<cr>
nnoremap <silent> <M-l> :TmuxNavigateRight<cr>
nnoremap <silent> <M-p> :TmuxNavigatePrevious<cr>

" Change window size
nnoremap <M->> <C-W>>
nnoremap <M-<> <C-W><
nnoremap <M-+> <C-W>+
nnoremap <M--> <C-W>-
nnoremap <M-=> <C-W>=

nnoremap <silent> <leader>q :call qftoggle#toggle()<cr>

" Command line {{{2

cnoremap <C-p> <Up>
cnoremap <C-n> <Down>
cnoremap <M-p> <C-p>
cnoremap <M-n> <C-n>

" expand %% to current directory
" cabbrev <expr> %% expand('%:~:h')
cnoremap <expr> %% getcmdtype() == ':' ? expand('%:h').'/' : '%%'

" Misc {{{2

" for quick macro playback
"nnoremap Q @q

" run current file as a script
nnoremap <leader>e :execute "Shell " . expand("%:p")<CR>

" Switch to current dir
nnoremap <silent> <leader>cd :cd %:p:h<cr>

nnoremap <S-F10> :call GenCscopeAndTags()<CR>

"inoremap  <Esc><Right>

" Modeline {{{1
" vim:tw=78 expandtab comments=\:\" foldmethod=marker foldenable foldcolumn=1
